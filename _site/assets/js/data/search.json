[
  
  {
    "title": "Two Dimensional Linear Systems",
    "url": "/posts/two-dimensional-linear-systems/",
    "categories": "robotics",
    "tags": "",
    "date": "2024-02-24 19:45:43 +0800",
    





    
    "snippet": "Two-dimensional Linear SystemsIn this example we will consider a two dimensional, holonomic system. We would like to track the following state vector\\[x = \\begin{bmatrix} p_{x} \\\\ p_{y} \\\\ v_{x} \\\\...",
    "content": "Two-dimensional Linear SystemsIn this example we will consider a two dimensional, holonomic system. We would like to track the following state vector\\[x = \\begin{bmatrix} p_{x} \\\\ p_{y} \\\\ v_{x} \\\\ v_{y} \\end{bmatrix}\\]Where $p_{x}$ and $p_{y}$ are position in $x$ and $y$ dimensions, and $v_{x}$ and $v_{y}$ are velocities in respective dimensions.The control vector is\\[u = \\begin{bmatrix} a_{x} \\\\ a_{y} \\end{bmatrix}\\]We can write how a holonomic system evolves using the laws of motion as:\\(p_{x+1} = p_{x} + v_{x} * dt + a_{x} * \\frac{dt^2}{2}\\) \\(p_{y+1} = p_{y} + v_{y} * dt + a_{y} * \\frac{dt^2}{2}\\) \\(v_{x+1} = v_{x} + a_{x} * dt\\) \\(v_{y+1} = v_{y} + a_{y} * dt\\) We can re-write the equations in the following way:\\(p_{x+1} = p_{x} * 1 + p_{y} * 0 + v_{x} * dt + v_{y} * 0 + a_{x} * \\frac{dt^2}{2} + a_{y} * 0\\) \\(p_{y+1} = p_{x} * 0 + p_{y} * 1 + v_{x} * 0 + v_{y} * dt + a_{x} * 0 + a_{y} * \\frac{dt^2}{2}\\) \\(v_{x+1} = p_{x} * 0 + p_{y} * 0 + v_{x} * 1 + v_{y} * 0 + a_{x} * dt + a_{y} * 0\\) \\(v_{y+1} = p_{x} * 0 + p_{y} * 0 + v_{x} * 0 + v_{y} * 1 + a_{x} * 0 + a_{y} * dt\\) Each of these equations is a sum of products of six variables. Four of these variables ($p_{x}, p_{y}, v_{x}, v_{y}$) are from the state itself and two ($a_{x}, a_{y}$) are from the controls. All six are present in each equation, but are multiplied by 1s, 0s or $dt$s. We can find the matrices $A$ and $B$ from this form equations easily. $A$ will be extracted using the first four terms in these equations and $B$ will be found from the last two terms.\\[A = \\begin{bmatrix} 1 &amp; 0 &amp; dt &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; dt \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\]\\[B = \\begin{bmatrix} \\frac{dt^2}{2} &amp; 0 \\\\ 0 &amp; \\frac{dt^2}{2} \\\\ dt &amp; 0 \\\\ 0 &amp; dt \\end{bmatrix}\\]Finally we can write our system of linear equations as:\\[x_{i+1} = Ax_{i} + Bu_{i}\\]\\[x_{i+1} = \\begin{bmatrix} 1 &amp; 0 &amp; dt &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; dt \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} p_{xi} \\\\ p_{yi} \\\\ v_{xi} \\\\ v_{yi} \\end{bmatrix} + \\begin{bmatrix} \\frac{dt^2}{2} &amp; 0 \\\\ 0 &amp; \\frac{dt^2}{2} \\\\ dt &amp; 0 \\\\ 0 &amp; dt \\end{bmatrix} \\begin{bmatrix} a_{xi} \\\\ a_{yi} \\end{bmatrix}\\]An interesting point to note: This system has two degrees of freedom, and it also has one control for each degree of freedom, which makes it a fully actuated system (if there are no limits on the acceleration, ofcourse)Now,its time to simulate such a systemSimulationimport numpy as npimport matplotlib.pyplot as plt%matplotlib notebook# Total simulation time (seconds)T = 10# delta-time (Resolution)dt = 0.1  # 0.1 seconds# Number of simulation time-stepssteps = int(T/dt)# Ground truth statesx_gt = []# Simulation Timet = np.linspace(0, T, steps)# Generating sine-wave acceleration commandsu = np.array([    np.sin(np.linspace(0, 2*np.pi, steps)),    np.sin(np.linspace(2*np.pi, -2*np.pi, steps))]).T# State transition matrixA = np.array([    [1, 0, dt, 0],    [0, 1, 0, dt],    [0, 0, 1, 0],    [0, 0, 0, 1]])# Control transition matrixB = np.array([    [0.5 * dt**2, 0],    [0, 0.5 * dt**2],    [dt, 0],    [0, dt]])# Specifying initial state (Starting from [0, 0, 0])x = np.array([    [0],  # px    [0],  # py    [0],  # vx    [0]   # vy])# Simulation loopfor i in range(len(u)):    x = A@x + B@u[i, :][:, np.newaxis]    x_gt.append(x)# Converting into numpy arrayx_gt = np.squeeze(np.array(x_gt))# Plotting the simulation dataplt.figure()plt.title('Position')plt.plot(x_gt[:, 0], x_gt[:, 1], label='position')plt.xlabel('x')plt.ylabel('y')plt.figure()plt.title('Velocities')plt.plot(t, x_gt[:, 2], label='velocity-x')plt.plot(t, x_gt[:, 3], label='velocity-y')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;&lt;IPython.core.display.Javascript object&gt;Generating noisy measurements from this ground-truth simulation dataimport copy# copying ground-truthx_noisy = copy.deepcopy(x_gt)# Adding gaussian noisex_noisy[:,0] += np.random.normal(loc=0, scale=0.5, size=x_noisy.shape[0])x_noisy[:,1] += np.random.normal(loc=0, scale=0.5, size=x_noisy.shape[0])x_noisy[:,2] += np.random.normal(loc=0, scale=0.25, size=x_noisy.shape[0])x_noisy[:,3] += np.random.normal(loc=0, scale=0.25, size=x_noisy.shape[0])# Plotting the simulation dataplt.figure()plt.title('Position')plt.plot(x_gt[:, 0], x_gt[:, 1], 'r', label='position ground-truth', alpha=0.5)plt.plot(x_noisy[:, 0], x_noisy[:, 1], 'r--', label='position measurement')plt.xlabel('x')plt.ylabel('y')plt.figure()plt.title('Velocities')plt.plot(t, x_gt[:, 2], 'b', label='velocity-x ground-truth', alpha=0.5)plt.plot(t, x_noisy[:, 2], 'b--', label='velocity-x')plt.plot(t, x_gt[:, 3], 'g', label='velocity-y ground-truth', alpha=0.5)plt.plot(t, x_noisy[:, 3], 'g--', label='velocity-y')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;&lt;IPython.core.display.Javascript object&gt;Filtering this noisy dataAssuming the states are measured directly and are synchronous# filtered statesx_filtered = []# We will use the same A, B, u, k and dt as used in simulation# In addition, we have to define the observation matrix, that maps the state vector into# a form that can be compared with the measurements# Observation matrixH = np.array([    [1, 0, 0, 0],  # px selection    [0, 1, 0, 0],  # py selection    [0, 0, 1, 0],  # vx selection    [0, 0, 0, 1]   # vy selection])# Initial statex = np.array([    [0], # px    [0], # py    [0], # vx    [0]  # vy])# Process covariance (In our case it should be zero, because our control applied during# simuation had no noisy actuation, but still we will consider some level of process noise# just for the sake of this implementation)Q = np.eye(4)        # 3x3 process noise matrixQ[0, 0] = 0.05 **2   # px varianceQ[1, 1] = 0.05 **2   # py varianceQ[2, 2] = 0.025 **2  # vx varianceQ[3, 3] = 0.025 **2  # vy variance# Measurement covariance (amount of noise in measured quantities)R = np.eye(4)        # 3x3 measurement noise matrixR[0, 0] = 0.5 **2    # px measurement varianceR[1, 1] = 0.5 **2    # py measurement varianceR[2, 2] = 0.25 **2   # vx measurement varianceR[3, 3] = 0.25 **2   # vy measurement variance# Initial process covariance (confidence in intial state specified)P = np.eye(4) * 0.1# Simulatingfor i in range(len(u)):        # ==== PREDICTION STEP ====    # 1. Extrapolating the state    x = A@x + B@u[i, :][:, np.newaxis]  # Ax + Bu        # 2. Extrapolating the process covariance matrix    P = A@P@A.T + Q        # Getting the noisy measurements from the sensor    measurement = x_noisy[i, :][:, np.newaxis]        # ==== CORRECTION STEP ====    # 1. Kalman Gain    K = P@H.T @ np.linalg.inv(H@P@H.T + R)        # 2. Update State Estimate    x = x + K @ (measurement - H@x)        # 3. Update Estimate Uncertainity    P = (np.eye(len(x)) - K@H) @ P @ (np.eye(len(x)) - K@H).T + K@R@K.T        # Appending the filtered position to list    x_filtered.append(x)    # Converting to numpy arrayx_filtered = np.squeeze(np.array(x_filtered))print(x_filtered.shape)# Plotting the simulation dataplt.figure()plt.title('Position')plt.plot(x_gt[:, 0], x_gt[:, 1], 'r', label='position ground-truth', alpha=0.5)plt.plot(x_filtered[:, 0], x_filtered[:, 1], 'r--', label='position filtered')plt.xlabel('x')plt.ylabel('y')plt.legend(loc='best')plt.figure()plt.title('Velocities')plt.plot(t, x_gt[:, 2], 'b', label='velocity-x ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 2], 'b--', label='velocity-x filtered')plt.plot(t, x_gt[:, 3], 'g', label='velocity-y ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 3], 'g--', label='velocity-y filtered')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()(100, 4)&lt;IPython.core.display.Javascript object&gt;&lt;IPython.core.display.Javascript object&gt;"
  },
  
  {
    "title": "Non Linear Systems And Kalman Filter",
    "url": "/posts/non-linear-systems-and-kalman-filter/",
    "categories": "robotics",
    "tags": "",
    "date": "2024-02-24 19:45:43 +0800",
    





    
    "snippet": "For non linear systems, we cannot use linear equations but the equations of Kalman filter are linear. A remedy that comes to mind is to do linear approximation of the non-linear functions. For a no...",
    "content": "For non linear systems, we cannot use linear equations but the equations of Kalman filter are linear. A remedy that comes to mind is to do linear approximation of the non-linear functions. For a non-linear motions model f you can approximate the matrix A by taking its jacobian. Similarly you can do the same for a non-linear observation model h and find the matrix H.The only thing is that you have to do this linear approximation in a loop, before every update.I am using a symbolic package casadi, but you can get the same results using sympy. I create a symbolic function for jacobian and just evaluate the jacobian at xi and extrapolate the state to xi+1 using the non-linear function. The jacobian matrix can now be used in Kalman filter equations.import numpy as npimport matplotlib.pyplot as pltimport copyfrom casadi import *%matplotlib notebookSimulation# Total simulation time (seconds)T = 10# delta-time (Resolution)dt = 0.1  # 0.1 seconds# Number of simulation time-stepssteps = int(T/dt)# Ground truth statesX_gt = []# Simulation Timet = np.linspace(0, T, steps)# Generating sine-wave acceleration commandsU = np.array([    np.linspace(0.5, 1, steps), # acceration input    np.linspace(-np.pi/4, np.pi/4, steps)  # steering input]).T# wheel base lengthl = 2.7  # metersdef motion_model(X, U, dt):    new_X = copy.deepcopy(X)    new_X[0] = X[0] + X[3] * cos(X[2]) * dt    new_X[1] = X[1] + X[3] * sin(X[2]) * dt    new_X[2] = X[2] + X[3] * tan(U[1])/l * dt    new_X[3] = X[3] + U[0] * dt        return new_X# Specifying initial stateX = np.array([    [0.0],    [0.0],    [0.0],    [0.0]])# Simulation loopfor i in range(U.shape[0]):    X = motion_model(X, U[i, :], dt)    X_gt.append(np.array(X))    # Converting into numpy arrayX_gt = np.squeeze(np.array(X_gt))print(X_gt.shape)# Plotting the simulation dataplt.figure()plt.plot(X_gt[:, 0], X_gt[:,1])plt.axis(\"equal\")plt.title(\"Position\")plt.figure()plt.plot(t, X_gt[:, 2], label='yaw angle (radians)')plt.plot(t, X_gt[:, 3], label='velocity (m/s)')plt.title('Simulation data')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()(100, 4)&lt;IPython.core.display.Javascript object&gt;&lt;IPython.core.display.Javascript object&gt;Generating noisy data# Converting into numpy arrayX_noisy = copy.deepcopy(X_gt)# Adding gaussian noiseX_noisy[:,0] += np.random.normal(loc=0, scale=0.25, size=X_noisy.shape[0]).TX_noisy[:,1] += np.random.normal(loc=0, scale=0.25, size=X_noisy.shape[0]).TX_noisy[:,2] += np.random.normal(loc=0, scale=0.1, size=X_noisy.shape[0]).TX_noisy[:,3] += np.random.normal(loc=0, scale=0.1, size=X_noisy.shape[0]).T# Plotting the simulation dataplt.figure()plt.plot(X_gt[:, 0], X_gt[:,1], 'r', label='ground-truth', alpha=0.5)plt.plot(X_noisy[:, 0], X_noisy[:,1], 'r--', label='measurement')plt.axis(\"equal\")plt.title(\"Position\")plt.legend(loc='best')plt.figure()plt.plot(t, X_noisy[:, 2], 'r--', label='yaw angle (radians) measurement')plt.plot(t, X_noisy[:, 3], 'b--', label='velocity (m/s) measurement')plt.plot(t, X_gt[:, 2], 'r', label='yaw angle (radians) ground-truth', alpha=0.5)plt.plot(t, X_gt[:, 3], 'b', label='velocity (m/s) ground-truth', alpha=0.5)plt.title('Simulation data')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;&lt;IPython.core.display.Javascript object&gt;Extended Kalman FilterX_filtered = []# Using the same controls generated in the simulation# Using the same wheel base as simulation# Measurement modeldef measurement_model(X):    \"\"\"    This function takes Xi, Ui and dt as input and returns the next state Xi+1    \"\"\"        new_X = copy.deepcopy(X)        return new_X# Process covariance (In our case it should be zero, because our control applied during# simuation had no noisy actuation, but still we will consider some level of process noise# just for the sake of this implementation)Q = np.eye(4)           # 3x3 process noise matrixQ[0, 0] = 0.025 **2     # x varianceQ[1, 1] = 0.025 **2    # y varianceQ[2, 2] = 0.01 **2      # theta varianceQ[3, 3] = 0.01 **2      # v variance# Measurement covariance (amount of noise in measured quantities)R = np.eye(4)       # 3x3 measurement noise matrixR[0, 0] = 0.5 **2     # x measurement varianceR[1, 1] = 0.5 **2   # y measurement varianceR[2, 2] = 0.1 **2  # theta measurement varianceR[3, 3] = 0.1 **2  # v measurement variance# Specifying initial stateX = np.array([    [0.0],    [0.0],    [0.0],    [0.0]])# Initial process covariance (confidence in intial state specified)P = np.eye(len(X)) * 0.1# Simulatingfor i in range(U.shape[0]):        # ==== PREDICTION STEP ====    # 1. Finding the A matrix by linearizing around the best estimate    V = MX.sym('V', 4)  # State vector representation    # Defining motion function    f = vertcat(V[0] + V[3] * np.cos(V[2]) * dt,                 V[1] + V[3] * np.sin(V[2]) * dt,                 V[2],                 V[3])        # Calculating jacobian    J = Function('A', [V], [jacobian(f, V)])        # Applying control    f += vertcat(0,                 0,                 (V[3] * np.tan(U[i, 1])/l) * dt,                 U[i, 0] * dt)    # Evaluating jacobian at X    A = np.array(J(X))        # 2. Extrapolating the state    F = Function('F', [V], [f])    X = F(X)        # 3. Extrapolating the process covariance matrix    P = A@P@A.T + Q            # Getting the noisy measurements from the sensor    measurement = X_noisy[i, :]        h = vertcat(V[0],                V[1],                V[2],                 V[3])    G = Function('G', [V], [jacobian(h, V)])    H = np.array(G(X))            # ==== CORRECTION STEP ====    # 1. Kalman Gain    K = P@H.T @ np.linalg.inv(H@P@H.T + R)        # 2. Update State Estimate    X = X + K @ (measurement - H@X)        # 3. Update Estimate Uncertainity    P = (np.eye(4) - K@H) @ P @ (np.eye(4) - K@H).T + K@R@K.T        # Appending the filtered position to list    X_filtered.append(np.array(X))X_filtered = np.array(X_filtered)    # Plotting the simulation dataplt.figure()plt.plot(X_gt[:, 0], X_gt[:,1], 'r', label='ground-truth', alpha=0.5)plt.plot(X_filtered[:, 0], X_filtered[:,1], 'r--', label='filtered')plt.axis(\"equal\")plt.title(\"Position\")plt.legend(loc='best')plt.figure()plt.plot(t, X_gt[:, 2], 'r', label='yaw angle (radians) ground-truth', alpha=0.5)plt.plot(t, X_filtered[:, 2], 'r--', label='yaw angle (radians) filtered')plt.plot(t, X_gt[:, 3], 'b', label='velocity (m/s) ground-truth', alpha=0.5)plt.plot(t, X_filtered[:, 3], 'b--', label='velocity (m/s) filtered')plt.title('Simulation data')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;&lt;IPython.core.display.Javascript object&gt;"
  },
  
  {
    "title": "Linear Systems And Kalman Filter",
    "url": "/posts/linear-systems-and-kalman-filter/",
    "categories": "robotics",
    "tags": "",
    "date": "2024-02-24 19:45:43 +0800",
    





    
    "snippet": "Linear SystemsWe are going to study some state of the art filters and their performance and behaviours in multiple scenarios. In the beginning, we are going to consider linear systems, which are of...",
    "content": "Linear SystemsWe are going to study some state of the art filters and their performance and behaviours in multiple scenarios. In the beginning, we are going to consider linear systems, which are of the form\\[x_{i+1} = Ax_{i} + Bu\\]Where $x_{i}$ is the current state and we can find the next state using the above equationLets consider the following state vector, that we would like to measure and keep track of\\[x = \\begin{bmatrix} p \\\\ v \\\\ a \\end{bmatrix}\\]where $p$ is position, $v$ is velocity, $a$ is accelerationThe state transition happens in the following way:\\(p_{i+1} = p_{i} * 1 + v_{i} * dt + a * dt^2\\)\\(v_{i+1} = p_{i} * 0 + v_{i} * 1 + a * dt\\)\\(a_{i+1} = p_{i} * 0 + v_{i} * 0 + a * 1\\)We can find the transition matrix $A$ from these expressions:\\[A = \\begin{bmatrix} 1 &amp; dt &amp; dt^2 \\\\ 0 &amp; 1 &amp; dt \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\]But we also have to consider the control input influence on state transition, which happens in the following way:\\(p_{i+1} = p_{i} * 1 + v_{i} * dt + a * dt^2 + 0\\)\\(v_{i+1} = p_{i} * 0 + v_{i} * 1 + a * dt + 0\\)\\(a_{i+1} = p_{i} * 0 + v_{i} * 0 + a * 0 + k * u_{T}\\)Here we can observe that only $k * u_{T}$ is added to acceleration, where $u_{T}$ is the Throttle value from the actuator and $k$ maps it into acceleration commands, zeros are added in the position and velocity. The acceleration is also multiplied by $0$ because now the acceleration is coming from the throttle. We can find the $A$ matrix and the control matrix $B$ from these expressions as:\\[A = \\begin{bmatrix} 1 &amp; dt &amp; dt^2 \\\\ 0 &amp; 1 &amp; dt \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}\\]\\[B = \\begin{bmatrix} 0 \\\\ 0 \\\\ k \\end{bmatrix}\\]Hence, the full system equation comes out to be:\\(x_{i+1} = Ax_{i} + Bu\\) $$x_{i+1} = \\begin{bmatrix} 1 &amp; dt &amp; dt^2 \\ 0 &amp; 1 &amp; dt \\ 0 &amp; 0 &amp; 0 \\end{bmatrix}  x_{i}  \\begin{bmatrix} 0 \\ 0 \\ k \\end{bmatrix}  u_{T}$$In short, $A$ is a matrix which maps old state to new state, and $B$ is a matrix that maps the control vector $u$ into a form that can be added in the state vectorSimulationNow we will simulate such a linear system, in order to generate data for filtering.import numpy as npimport matplotlib.pyplot as plt%matplotlib notebook# Total simulation time (seconds)T = 10# delta-time (Resolution)dt = 0.1  # 0.1 seconds# Number of simulation time-stepssteps = int(T/dt)# Ground truth statesx_gt = []# Simulation Timet = np.linspace(0, T, steps)# Generating sine-wave acceleration commandsu = np.sin(np.linspace(0, 2*np.pi, steps))# k value to map throttle to accelerationk = 1    # k=1 directly maps throttle value to acceleration# State transition matrixA = np.array([    [1, dt, dt**2],    [0, 1,  dt],    [0, 0,  0]])# Control transition matrixB = np.array([    [0],    [0],    [k]])# Specifying initial state (Starting from [0, 0, 0])x = np.array([    [0],    [0],    [0]])# Simulation loopfor i in range(len(u)):    x = A@x + B*u[i]    x_gt.append(x)# Converting into numpy arrayx_gt = np.array(x_gt)# Plotting the simulation dataplt.figure()plt.plot(t, x_gt[:, 0], label='position')plt.plot(t, x_gt[:, 1], label='velocity')plt.plot(t, x_gt[:, 2], label='accleration')plt.title('Simulation data')plt.xlabel('Time (seconds)')plt.ylabel('States')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;We can generate noisy measurements from this ground-truth simulation dataimport copy# copying ground-truthx_noisy = copy.deepcopy(x_gt)# Adding gaussian noisex_noisy[:,0] += np.random.normal(loc=0, scale=1, size=x_noisy.shape[0])[np.newaxis].Tx_noisy[:,1] += np.random.normal(loc=0, scale=0.5, size=x_noisy.shape[0])[np.newaxis].Tx_noisy[:,2] += np.random.normal(loc=0, scale=0.25, size=x_noisy.shape[0])[np.newaxis].T# Plotting the measurements dataplt.figure()plt.plot(t, x_gt[:, 0], 'b', label='position ground-truth', alpha=0.5)plt.plot(t, x_noisy[:, 0], 'b--', label='position measurement')plt.plot(t, x_gt[:, 1], 'g', label='velocity ground-truth', alpha=0.5)plt.plot(t, x_noisy[:, 1], 'g--', label='velocity measurement')plt.plot(t, x_gt[:, 2], 'r', label='accleration ground-truth', alpha=0.5)plt.plot(t, x_noisy[:, 2], 'r--', label='accleration measurement')plt.title('Measurement data')plt.xlabel('Time (seconds)')plt.ylabel('Measurements')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;Standard Kalman filteringNow lets filter the above measurement data using a standard kalman filter and compare it to the ground-truth simulation dataStandard kalman filter models the system as a linear system (even when the actual system is non-linear), unfortunately we have to work with the same linear system defined above, but this implementation is practically same to how you would filter a real world systemWe have to form an $H$ matrix in order to calculate the difference between the expected measurement and the actual observation. The difference between expectation and measurement is calculated in the following way:\\(Z - Hx\\)Where $H$ is the observation model, $x$ is your extrapolated state and $Z$ is the actual measurement from the sensor. As you can see, $H$ simply transforms your state into a form that can be compared with the sensor measurement.For the model discussed above, lets say that we can measure the position, velocity and acceleration, then our measurement vector $Z$ would look like \\(Z = \\begin{bmatrix} p_{measured} \\\\ v_{measured} \\\\ a_{measured} \\end{bmatrix}\\)If our extrapolated state $x$ is:\\(x_{predicted} = \\begin{bmatrix} p_{predicted} \\\\ v_{predicted} \\\\ a_{predicted} \\end{bmatrix}\\)Then we can choose a matrix $H$ such that is causes corresponding entries to be subtracted when written in $Z-Hx$ form.Lets say that the $H$ matrix is:\\(H = \\begin{bmatrix} 1 &amp;&amp; 0 &amp;&amp; 0 \\\\ 0 &amp;&amp; 1 &amp;&amp; 0 \\\\ 0 &amp;&amp; 0 &amp;&amp; 1 \\end{bmatrix}\\)Now if we calculate $Hx$, we will actually get the state vector $x$ back. $Hx = x$. Because $H$ is an identity matrix.Further on, we will look at some other examples, in which we will have to choose this $H$ matrix wisely. But for this particular scenario, this $H$ matrix is the correct observation model.If you are new to filtering, then you must know that there are some more matrices needed for Kalman filtering, some other important ones are the $Q$ and $R$ matrix. These matrices are the covaraince matrices to represent motion and observation model uncertainity. $Q$ is the motion model uncertainity matrix and $R$ is the observation model uncertainity or measurement covariance matrix. These matrices are usually specified by the user. You must specify these matrices to properly represent the varainces in your motion and sensors.# filtered statesx_filtered = []# We will use the same A, B, u, k and dt as used in simulation# In addition, we have to define the observation matrix, that maps the state vector into# a form that can be compared with the measurements# Observation matrixH = np.array([    [1, 0, 0],  # Position selection    [0, 1, 0],  # Velocity selection    [0, 0, 1]   # Acceleration selection])# Initial statex = np.array([    [0],    [0],    [0]])# Process covariance (In our case it should be zero, because our control applied during# simuation had no noisy actuation, but still we will consider some level of process noise# just for the sake of this implementation)Q = np.eye(3)           # 3x3 process noise matrixQ[0, 0] = 0.025 **2     # position varianceQ[1, 1] = 0.0125 **2    # velocity varianceQ[2, 2] = 0.01 **2      # acceleration variance# Measurement covariance (amount of noise in measured quantities)R = np.eye(3)       # 3x3 measurement noise matrixR[0, 0] = 1 **2     # position measurement varianceR[1, 1] = 0.5 **2   # velocity measurement varianceR[2, 2] = 0.25 **2  # acceleration measurement variance# Initial process covariance (confidence in intial state specified)P = np.eye(3) * 0.1# Simulatingfor i in range(len(u)):        # ==== PREDICTION STEP ====    # 1. Extrapolating the state    x = A@x + B*u[i]  # Ax + Bu        # 2. Extrapolating the process covariance matrix    P = A@P@A.T + Q        # Getting the noisy measurements from the sensor    measurement = x_noisy[i, :]            # ==== CORRECTION STEP ====    # 1. Kalman Gain    K = P@H.T @ np.linalg.inv(H@P@H.T + R)        # 2. Update State Estimate    x = x + K @ (measurement - H@x)        # 3. Update Estimate Uncertainity    P = (np.eye(3) - K@H) @ P @ (np.eye(3) - K@H).T + K@R@K.T        # Appending the filtered position to list    x_filtered.append(x)    # Converting to numpy arrayx_filtered = np.array(x_filtered)# Plotting the filter comparison dataplt.figure()plt.plot(t, x_gt[:, 0], 'b', label='position ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 0], 'b--', label='position filtered')plt.plot(t, x_gt[:, 1], 'g', label='velocity ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 1], 'g--', label='velocity filtered')plt.plot(t, x_gt[:, 2], 'r', label='accleration ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 2], 'r--', label='accleration filtered')plt.title('Filter Comparison')plt.xlabel('Time (seconds)')plt.ylabel('Measurements')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;Kalman filtering with non-synchronous sensor measurementsNow we are going to consider a case when our measurements are not synchronous. What would be our observation model matrix $H$ in the case when the measurements for position, velocity and acceleration are coming at different time steps?Lets find out!First of all, we have to realize that whenever we are about to perform an update based on a sensor measurement, we need to have the predicted state from the filter for that time-stamp. For example, if a position measurement arrives at time $t$, then we should also have the predicted position at time $t$, so that we can calculate the difference between the two and then update the state vector $x$ using the right $H$ matrix.There are two steps in Kalman filter (“Prediction” and “Update”). And it should be clear that before every “Update”, we must have the “Prediction” from the filter. Hence, we need a modular $A$ matrix, which gives us the prediction at a desired interval. Hence $A$ will not be a constant matrix, instead we will update it inside the loop, based on the time interval between the sensor readings.Before we proceed any further, firstly we need to construct a list of measurements, that are not synchronized. I will use a dictionary for it.Dictionary of (non-synchronized) sensor measurementsmeasurements = {}for i in range(x_gt.shape[0]):        # We will take measurements from position, velovity and acceleration successively    # instead of synchronously now        if i%3 == 0:        # Position measurement        measurements[i] = {            \"time\": t[i],            \"sensor\": \"position\",            \"measurement\": x_noisy[i, 0]        }            if i%3 == 1:        # Velocity measurement        measurements[i] = {            \"time\": t[i],            \"sensor\": \"velocity\",            \"measurement\": x_noisy[i, 1]        }            if i%3 == 2:        # Acceleration measurement        measurements[i] = {            \"time\": t[i],            \"sensor\": \"acceleration\",            \"measurement\": x_noisy[i, 2]        }        # Displaying first ten measurementsprint(\"First ten measurements are:\\n\")for i in range(10):    print(measurements[i])First ten measurements are:{'time': 0.0, 'sensor': 'position', 'measurement': array([0.77573052])}{'time': 0.10101010101010101, 'sensor': 'velocity', 'measurement': array([-0.06011667])}{'time': 0.20202020202020202, 'sensor': 'acceleration', 'measurement': array([-0.01125531])}{'time': 0.30303030303030304, 'sensor': 'position', 'measurement': array([-1.23684164])}{'time': 0.40404040404040403, 'sensor': 'velocity', 'measurement': array([0.02697425])}{'time': 0.5050505050505051, 'sensor': 'acceleration', 'measurement': array([0.36007771])}{'time': 0.6060606060606061, 'sensor': 'position', 'measurement': array([1.54602323])}{'time': 0.7070707070707071, 'sensor': 'velocity', 'measurement': array([0.21437572])}{'time': 0.8080808080808081, 'sensor': 'acceleration', 'measurement': array([0.61254052])}{'time': 0.9090909090909091, 'sensor': 'position', 'measurement': array([-1.19768566])}Now that we have a dictionary of non-synchronous measurements, we need to treat each measurement differently i.e. we need to have three observation models, one for each sensor. Now, instead of one $H$ matrix, now we will have three matrices $H_{position}$, $H_{velocity}$ and $H_{acceleration}$. Each of these matrices will be responsible for selecting the right entry from the state vector $x$, so as to get subtracted from the measured value.Now lets create the filter…# filtered statesx_filtered = []# Observation matricesH_position = np.array([    [1, 0, 0],      # Position selection    [0, 0, 0],    [0, 0, 0]])H_velocity = np.array([    [0, 0, 0],    [0, 1, 0],      # Velocity selection    [0, 0, 0]])H_acceleration = np.array([    [0, 0, 0],    [0, 0, 0],    [0, 0, 1]       # acceleration selection])\"\"\"There are other ways of treating these H matrices as single row matrices, but if we do that, we will haveto adjust the dimensions of other matrices as well, to avoid dimension mis-match errors. For now,lets be lazy leave them as 3x3 matrices, with non relevant entries changed to zero. In practice, thisis not efficient, it will certainly not cause any observable performance issues, but still we can furtheroptimize this implementation, if we want to.\"\"\"# Initial statex = np.array([    [0],    [0],    [0]])# Process covariance (In our case it should be zero, because our control applied during# simuation had no noisy actuation, but still we will consider some level of process noise# just for the sake of this implementation)Q = np.eye(3)           # 3x3 process noise matrixQ[0, 0] = 0.025 **2     # position varianceQ[1, 1] = 0.0125 **2    # velocity varianceQ[2, 2] = 0.01 **2      # acceleration variance# Measurement covariance (amount of noise in measured quantities)R = np.eye(3)       # 3x3 measurement noise matrixR[0, 0] = 1 **2     # position measurement varianceR[1, 1] = 0.5 **2   # velocity measurement varianceR[2, 2] = 0.25 **2  # acceleration measurement variance# Initial process covariance (confidence in intial state specified)P = np.eye(3) * 0.1# Simulatingprev_time = 0for i in range(len(u)):        ## A new measurment arrives    measurement_dict = measurements[i]    time = measurement_dict['time']         ## Time stamp    sensor = measurement_dict['sensor']     ## Sensor type    measurement = measurement_dict['measurement'] ## Measured value        # Time difference between the old and new measurements    dt = time - prev_time            # ==== PREDICTION STEP ====    # 1. Updating the A matrix based on dt    A = np.array([        [1, dt, dt**2],        [0, 1,  dt],        [0, 0,  0]    ])        # 2. Extrapolating the state    x = A@x + B*u[i]  # Ax + Bu        # 3. Extrapolating the process covariance matrix    P = A@P@A.T + Q            # ==== CORRECTION STEP ====        # 1. Choosing the right observation model, based on sensor type    if sensor == 'position':        H = H_position    elif sensor == 'velocity':        H = H_velocity    elif sensor == 'acceleration':        H = H_acceleration    else:        raise NotImplementedError        # 2. Kalman Gain    K = P@H.T @ np.linalg.inv(H@P@H.T + R)        # 3. Update State Estimate    x = x + K @ (measurement - H@x)        # 4. Update Estimate Uncertainity    P = (np.eye(3) - K@H) * P * (np.eye(3) - K@H).T + K@R@K.T        # Appending the filtered position to list    x_filtered.append(x)        # Updating prev-time    prev_time = time    # Converting to numpy arrayx_filtered = np.array(x_filtered)# Plotting the filter comparison dataplt.figure()plt.plot(t, x_gt[:, 0], 'b', label='position ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 0], 'b--', label='position filtered')plt.plot(t, x_gt[:, 1], 'g', label='velocity ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 1], 'g--', label='velocity filtered')plt.plot(t, x_gt[:, 2], 'r', label='accleration ground-truth', alpha=0.5)plt.plot(t, x_filtered[:, 2], 'r--', label='accleration filtered')plt.title('Filter Comparison')plt.xlabel('Time (seconds)')plt.ylabel('Measurements')plt.legend(loc='best')plt.show()&lt;IPython.core.display.Javascript object&gt;TODO Next : Filters with switching motion and observation modelsI would like to discuss and explain filters that have switching observation and measurement models. In real world, the observation and measurement models are not static. They can change depending upon the state of the system. For example, your sensor is working normally on a sunny day, and is in nominal working conditions, but on a rainy day, it performs differently. Or lets say, that your car is running in nominal conditions usually, but if one of its tyres is flat, then suddenly your actual motion model of the system is changed. Or lets say that your sensor has failed completely and is giving no output.To detect and cater for such scenarios, in your filter, you have to account for multiple motion and observation models. And you can switch between them, to have a better estimate, as well as you can detect these failures.We will also cover some filters for non-linear and non-holonomic systems moving in multiple dimensions (in future). Sorry, but you will have to wait for further implementations here, so stay tuned.And if you like my work, you can support it by giving it a star and following me on github. It would be great if you check out my other repositories as well, and maybe star them too if you happen to like them. Thankyou :)The ones who are curious can explore the following topics meanwhile:  Switching Kalman Filters  Change point detection  Particle Filters"
  }
  
]

